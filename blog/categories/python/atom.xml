<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | @Lenciel]]></title>
  <link href="http://lenciel.cn/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://lenciel.cn/"/>
  <updated>2014-04-29T16:28:11+08:00</updated>
  <id>http://lenciel.cn/</id>
  <author>
    <name><![CDATA[Lenciel Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fix Python after upgrade to Maverick]]></title>
    <link href="http://lenciel.cn/2013/10/maverick-and-python/"/>
    <updated>2013-10-24T22:02:00+08:00</updated>
    <id>http://lenciel.cn/2013/10/maverick-and-python</id>
    <content type="html"><![CDATA[<p>升级到最新的osx版本Maverick之后，打开iTerm2就报错：</p>

<p><code>bash
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named virtualenvwrapper.hook_loader
virtualenvwrapper.sh: There was a problem running the initialization hooks.
If Python could not import the module virtualenvwrapper.hook_loader,
check that virtualenv has been installed for
VIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH is
set properly.
</code></p>

<p>敲pip之后也报错：</p>

<p><code>bash
Traceback (most recent call last):
  File "/usr/local/bin/pip", line 5, in &lt;module&gt;
    from pkg_resources import load_entry_point
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/pkg_resources.py", line 2603, in &lt;module&gt;
    working_set.require(__requires__)
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/pkg_resources.py", line 666, in require
    needed = self.resolve(parse_requirements(requirements))
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/pkg_resources.py", line 565, in resolve
    raise DistributionNotFound(req)  # XXX put more info here
pkg_resources.DistributionNotFound: pip==1.3.1
</code></p>

<p>这坨<code>pkg_resources.DistributionNotFound</code>的错正好前两天装CentOS的机器<a href="http://stackoverflow.com/questions/7446187/no-module-named-pkg-resources">看到过</a>。</p>

<p>运行下面的命令更新了<code>setuptools</code>之后重装了<code>pip</code>和<code>virtualenv</code>、<code>virtualenvwrapper</code>就好了：</p>

<p><code>bash
wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py
sudo python ez_setup.py
sudo easy_install -U pip
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打开pip的download cache]]></title>
    <link href="http://lenciel.cn/2013/10/pip-download-cache/"/>
    <updated>2013-10-17T13:25:00+08:00</updated>
    <id>http://lenciel.cn/2013/10/pip-download-cache</id>
    <content type="html"><![CDATA[<p>Python的标准库实在是<a href="http://lenciel.cn/2013/10/recharging-the-python-standard-library/">不够用</a>，所以一个很常见的情况是我们需要在每个项目使用的<code>virtualenv</code>里面都安装一些常用的库。</p>

<p>为了加速安装的过程，有两个小窍门。</p>

<p>一个是使用国内的源，比如<a href="http://www.v2ex.com/">v2ex</a>提供的。只需要新建或者编辑<code>~/.pip/pip.conf</code>，加入一行：</p>

<p>```
[global]
index-url = http://pypi.v2ex.com/simple</p>

<p>```</p>

<p>另一个就是打开pip的<code>download cache</code>，这样可以避免pip每次都去下载相同的东西。只需要在<code>.bashrc</code>或者是<code>.zshrc</code>里面加入一行：</p>

<p>```
export PIP_DOWNLOAD_CACHE=$HOME/.pip-download-cache</p>

<p>```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Python标准库充电]]></title>
    <link href="http://lenciel.cn/2013/10/recharging-the-python-standard-library/"/>
    <updated>2013-10-17T12:27:00+08:00</updated>
    <id>http://lenciel.cn/2013/10/recharging-the-python-standard-library</id>
    <content type="html"><![CDATA[<p>Python的自荐页面<a href="http://www.python.org/about/">About Python</a>上号称自家的标准库是”batteries included”的，但实际情况却不是这样。对Python标准库的批评几乎从来没有中断过。著名的Python包<a href="http://docs.python-requests.org/en/latest/">Requests</a>的作者甚至决定永久把Requests保持为第三方库而拒绝加入标准库，他的理由是：<a href="http://www.leancrew.com/all-this/2012/04/where-modules-go-to-die/">加入标准库就会死翘翘</a>。</p>

<p>再举个例子，我们最近的项目里面都用到了<a href="https://pypi.python.org/pypi/pytz/">pytz</a>。标准库里面的datetime是支持时区的（tzinfo类），但是并没有包含时区信息（tzinfo是抽象类需要自己实现）。遵照前人的经验使用pytz是最好的办法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>

<p>所以不奇怪的是，几乎所有的Python项目都会引用一堆优秀的第三方库。为了管理这些依赖一般都会用上pip:</p>

<ul>
  <li>在项目里面用pip freeze生成一个<code>requirement.txt</code>文件</li>
  <li>在创建<code>virtualenv</code>的时候使用之前生成的文件安装所有的依赖</li>
</ul>

<p>为了不在每次运行<code>pip install -r requirements.txt</code>的时候都下载一堆依赖，你还可以打开pip的<a href="http://lenciel.cn/2013/10/pip-download-cache/">download cache</a>。如果整个公司在做项目的时候都需要经常使用一些包，甚至可以考虑<a href="https://github.com/wolever/pip2pi">做一个Pypi</a>的库来共享，类似于Maven的Repo。</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://stackoverflow.com/questions/2532729/daylight-saving-time-and-time-zone-best-practices/3404919#3404919">保存时间和时区的最佳实践</a>.   <a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="http://stackoverflow.com/questions/14762518/python-datetime-strptime-and-strftime-how-to-preserve-the-timezone-informat">如何在datetime转换中保存时区信息</a>.    <a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cryptography and Python]]></title>
    <link href="http://lenciel.cn/2013/07/cryptography-and-python/"/>
    <updated>2013-07-25T15:13:00+08:00</updated>
    <id>http://lenciel.cn/2013/07/cryptography-and-python</id>
    <content type="html"><![CDATA[<p>这周我们的一个项目里面需要调用第三方接口。对方的安全机制是调用时要进行加密和校验，但它们的文档没有描述具体是怎么加密的，而是给了一段代码：</p>

<p>```java
    private static BASE64Encoder base64 = new BASE64Encoder();
//  private static byte[] myIV = { 50, 51, 52, 53, 54, 55, 56, 57 };
//  private static byte[] myIV = null;
//  private static String strkey = “W9qPIzjaVGKUp7CKRk/qpCkg/SCMkQRu”; // 字节数必须是8的倍数
    //密钥
    private static String strkey = “NDg5MDY2NjczMxxxxXXXXXyNzUzNTg2”;
    private static String removeBR(String str) {
        StringBuffer sf = new StringBuffer(str);</p>

<pre><code>    for (int i = 0; i &lt; sf.length(); ++i)
    {
      if (sf.charAt(i) == '\n')
      {
        sf = sf.deleteCharAt(i);
      }
    }
    for (int i = 0; i &lt; sf.length(); ++i)
    {
      if (sf.charAt(i) == '\r')
      {
        sf = sf.deleteCharAt(i);
      }
    }
    return sf.toString();
}

private static String desEncrypt(String input) throws Exception
{

    BASE64Decoder base64d = new BASE64Decoder();
    DESedeKeySpec p8ksp = null;
    p8ksp = new DESedeKeySpec(base64d.decodeBuffer(strkey));
    Key key = null;
    key = SecretKeyFactory.getInstance("DESede").generateSecret(p8ksp);

    byte[] plainBytes = (byte[])null;
    Cipher cipher = null;
    byte[] cipherText = (byte[])null;
    //“算法/模式/填充”
    plainBytes = input.getBytes("UTF8");
    cipher = Cipher.getInstance("DESede/ECB/PKCS5Padding");
    SecretKeySpec myKey = new SecretKeySpec(key.getEncoded(), "DESede");  //       IvParameterSpec ivspec = new IvParameterSpec(myIV);
    cipher.init(1, myKey);
    cipherText = cipher.doFinal(plainBytes);
    return removeBR(base64.encode(cipherText));
}

private static String desDecrypt(String cipherText) throws Exception
{

    BASE64Decoder base64d = new BASE64Decoder();
    DESedeKeySpec p8ksp = null;
    p8ksp = new DESedeKeySpec(base64d.decodeBuffer(strkey));
    Key key = null;
    key = SecretKeyFactory.getInstance("DESede").generateSecret(p8ksp);

    Cipher cipher = null;
    byte[] inPut = base64d.decodeBuffer(cipherText);
    //“算法/模式/填充”
    cipher = Cipher.getInstance("DESede/ECB/PKCS5Padding");
    SecretKeySpec myKey = new SecretKeySpec(key.getEncoded(), "DESede");  //       IvParameterSpec ivspec = new IvParameterSpec(myIV);
    cipher.init(2, myKey);
    byte[] output = cipher.doFinal(inPut);
    return new String(output, "UTF8");
} ```
</code></pre>

<p>很明显，在提供文档的同学看来大家都是JEE程序员。仔细看了半天这两个函数<code>desEncrypt</code>和<code>desDecrypt</code>外加Google，才明白是<code>DES3</code>算法。</p>

<p>接着这份文档的后面还有另一个对加密的描述也是代码，不过这次比较明显是MD5：</p>

<p>```java
public static final String MD5(String s)
{
  char hexDigits[] = {
    ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’,
    ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’
    };
  char str[] = null;
  byte strTemp[] = s.getBytes();
  MessageDigest mdTemp;
  try {
    mdTemp = MessageDigest.getInstance(“MD5”);
    mdTemp.update(strTemp);
    byte md[] = mdTemp.digest();
    int j = md.length;
    str = new char[j * 2];
    int k = 0;
    for (int i = 0; i &lt; j; i++)
    {
      byte b = md[i];
      str[k++] = hexDigits[b » 4 &amp; 0xf];
      str[k++] = hexDigits[b &amp; 0xf];
    }
  } catch (NoSuchAlgorithmException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
  }</p>

<p>return new String(str);
}
```</p>

<p>这些算法用python来实现当然就简单多了:MD5就是一句话，看起来非常复杂的DES3也不过几句话:</p>

<p>```python
from pyDes import triple_des, ECB, PAD_PKCS5
import base64
import datetime</p>

<p>input_str = “test string”</p>

<p>key_base64_str = base64.b64decode(“NDg5MDY2NjczMxxxxXXXXXyNzUzNTg2”, “utf-8”)
key_bytes = key_base64_str.encode(‘utf-8’)
k = triple_des(key_bytes, ECB, pad=None, padmode=PAD_PKCS5)
d = base64.b64encode(k.encrypt(input_str))
print d
```</p>

<p>当然，要明白这些算法究竟怎么回事才叫认真负责的态度。</p>

<h2 id="hash"><strong>Hash</strong></h2>

<p>hash就是给输入的字符串生成一个固定长度的字符串（被称为hash值）。理想的hash要满足：</p>

<ul>
  <li>根据生成的字符串非常难猜到输入的字符串</li>
  <li>任意两个不同的字符串不会生成相同的hash值</li>
  <li>如果输入字符串没有变生成的hash值应该不会变</li>
</ul>

<p><img src="/downloads/images/hash.png" alt="hash" title="Don't touch me..." /></p>

<p>hash函数可以被用来计算checksum，也可以用来进行数字签名和认证。</p>

<h3 id="md5"><strong>MD5</strong></h3>

<p>1991年面世的一种hash算法，生成的字符串长度为128bit。</p>

<p>它的算法详情可以看<a href="http://tools.ietf.org/html/rfc1321">这里</a>，简单说如下：</p>

<ul>
  <li>首先需要对字符串进行扩展，使其位长对512求余的结果等于448。因此，位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。填充的方法一般是在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。</li>
  <li>然后，在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的位长是 <code>N*512+448+64 = (N+1）*512</code>，即长度恰好是512的整数倍。</li>
  <li>最后以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</li>
</ul>

<p>MD5对碰撞攻击(不同的输入生成相同的hash)等攻击的抵抗力比较差。</p>

<p>在python中使用MD5:</p>

<p>```python
import os
from Crypto.Hash import MD5</p>

<p>def get_file_checksum(filename):
    h = MD5.new()
    chunk_size = 8192
    with open(filename, ‘rb’) as f:
        while True:
            chunk = f.read(chunk_size)
            if len(chunk) == 0:
                break
            h.update(chunk)
    return h.hexdigest()
```</p>

<h2 id="section"><strong>加密算法</strong></h2>

<p>加密算法使用key把输入的文本变成加密的文本。有两种加密的方式：分块和流。分块处理的单位是固定大小比如8或者16个bytes，流则是一个一个byte。只有知道了解密的<code>key</code>才能对加密的文本进行解密。</p>

<h3 id="section-1"><em>分块</em></h3>

<p>DES是分块加密的一种，其处理对象的大小是8个bytes。DES最简单的模式是所谓的<code>ECB( electronic code book)模式</code>，也就是每个block都是独立加密，最后组成整个加密后的文本。</p>

<p><img src="/downloads/images/block_cipher_ebc.png" alt="ecb" title="Don't touch me..." /></p>

<p>使用pycrpto对文本使用<code>DES/ECB</code>加密很简单。假设key是<code>10234567</code>，而我们要加密的文本是<code>abcdefgh</code>，那么：</p>

<p><code>python
&gt;&gt;&gt; from Crypto.Cipher import DES
&gt;&gt;&gt; des = DES.new('01234567', DES.MODE_ECB)
&gt;&gt;&gt; text = 'abcdefgh'
&gt;&gt;&gt; cipher_text = des.encrypt(text)
&gt;&gt;&gt; cipher_text
'\xec\xc2\x9e\xd9] a\xd0'
&gt;&gt;&gt; des.decrypt(cipher_text)
'abcdefgh'
</code></p>

<p>比<code>ECB</code>更健壮的是<code>CFB (Cipher feedback)</code>模式，也就是先组合前面加密的文本和待加密的文本，然后进行加密。</p>

<p><img src="/downloads/images/block_cipher_cfb.png" alt="cfb" title="Don't touch me..." /></p>

<p>下面的例子说明了算法的工作流程：待加密的是<code>abcdefghijklmnop</code>，两倍8bytes。首先生成一个随机的字符串作为初始的<code>iv</code>来生成两个<code>DES</code>对象，一个用来加密一个用来解密。之所以需要这两个对象，是因为<code>feedback</code>值会随着block被加密后变化。</p>

<p><code>python
&gt;&gt;&gt; from Crypto.Cipher import DES
&gt;&gt;&gt; from Crypto import Random
&gt;&gt;&gt; iv = Random.get_random_bytes(8)
&gt;&gt;&gt; des1 = DES.new('01234567', DES.MODE_CFB, iv)
&gt;&gt;&gt; des2 = DES.new('01234567', DES.MODE_CFB, iv)
&gt;&gt;&gt; text = 'abcdefghijklmnop'
&gt;&gt;&gt; cipher_text = des1.encrypt(text)
&gt;&gt;&gt; cipher_text
"?\\\x8e\x86\xeb\xab\x8b\x97'\xa1W\xde\x89!\xc3d"
&gt;&gt;&gt; des2.decrypt(cipher_text)
'abcdefghijklmnop'
</code></p>

<h3 id="section-2"><em>流</em></h3>

<p>这些算法基于一个个bytes，所以block的大小总是1 byte。pycrypto提供了两个这样的算法：<code>ARC4</code> 和 <code>XOR</code>。这种基于流的算法只有一种模式：<code>ECB</code>。</p>

<p>下面是一个<code>ARC4</code>的算法，使用了key <code>01234567</code>:</p>

<p><code>python
&gt;&gt;&gt; from Crypto.Cipher import ARC4
&gt;&gt;&gt; obj1 = ARC4.new('01234567')
&gt;&gt;&gt; obj2 = ARC4.new('01234567')
&gt;&gt;&gt; text = 'abcdefghijklmnop'
&gt;&gt;&gt; cipher_text = obj1.encrypt(text)
&gt;&gt;&gt; cipher_text
'\xf0\xb7\x90{#ABXY9\xd06\x9f\xc0\x8c '
&gt;&gt;&gt; obj2.decrypt(cipher_text)
'abcdefghijklmnop'
</code></p>

<h3 id="section-3"><strong>应用程序</strong></h3>

<p>在程序里面我们常常使用DES3对文件进行加密解密操作。一般来说操作对象是文件时，总是分成一个个chunck来处理以免占用太多内存。如果读入的chunck少于16bytes，就需要扩展它才能进行加密。</p>

<p>```python
import os
from Crypto.Cipher import DES3</p>

<p>def encrypt_file(in_filename, out_filename, chunk_size, key, iv):
    des3 = DES3.new(key, DES3.MODE_CFB, iv)</p>

<pre><code>with open(in_filename, 'r') as in_file:
    with open(out_filename, 'w') as out_file:
        while True:
            chunk = in_file.read(chunk_size)
            if len(chunk) == 0:
                break
            elif len(chunk) % 16 != 0:
                chunk += ' ' * (16 - len(chunk) % 16)
            out_file.write(des3.encrypt(chunk))
</code></pre>

<p>def decrypt_file(in_filename, out_filename, chunk_size, key, iv):
    des3 = DES3.new(key, DES3.MODE_CFB, iv)</p>

<pre><code>with open(in_filename, 'r') as in_file:
    with open(out_filename, 'w') as out_file:
        while True:
            chunk = in_file.read(chunk_size)
            if len(chunk) == 0:
                break
            out_file.write(des3.decrypt(chunk)) ```
</code></pre>

<p>有了上面定义的这两个函数我们可以这样使用它们：</p>

<p><code>python
from Crypto import Random
iv = Random.get_random_bytes(8)
with open('to_enc.txt', 'r') as f:
    print 'to_enc.txt: %s' % f.read()
encrypt_file('to_enc.txt', 'to_enc.enc', 8192, key, iv)
with open('to_enc.enc', 'r') as f:
    print 'to_enc.enc: %s' % f.read()
decrypt_file('to_enc.enc', 'to_enc.dec', 8192, key, iv)
with open('to_enc.dec', 'r') as f:
    print 'to_enc.dec: %s' % f.read()
</code></p>

<p>程序的输出如下：</p>

<p>```bash
to_enc.txt: this content needs to be encrypted.</p>

<p>to_enc.enc: ??~?E??.??]!=)??”t?
                                JpDw???R?UN0?=??R?UN0?}0r?FV9
to_enc.dec: this content needs to be encrypted.
```</p>

<h2 id="public-key-algorithms"><strong>Public-key algorithms</strong></h2>

<p>上面提到的加密算法的一大问题是双方都需要知道key。而<code>public-key算法</code>提供了两个key，一个用来加密，一个用来解密。 </p>

<p><img src="/downloads/images/public_private_key.png" alt="ecb" title="Don't touch me..." /></p>

<h3 id="publicprivate-key"><strong>public/private key</strong></h3>

<p>使用pycrpto很容易就可以生成一对<code>private/public key</code>，生成key的时候必须规定key的长度，越长越安全。除开长度，还需要设定生成key的方法。下面是一个使用RSA生成1024bit长度key的过程：</p>

<p><code>python
&gt;&gt;&gt; from Crypto.PublicKey import RSA
&gt;&gt;&gt; from Crypto import Random
&gt;&gt;&gt; random_generator = Random.new().read
&gt;&gt;&gt; key = RSA.generate(1024, random_generator)
&gt;&gt;&gt; key
&lt;_RSAobj @0x7f60cf1b57e8 n(1024),e,d,p,q,u,private&gt;
</code></p>

<p>key对象有一系列的方法：
- <code>can_encrypt()</code> 返回是否能用key来加密数据 
- <code>can_sign()</code> 返回是否能用key来进行签名
- <code>has_private()</code> 返回是否有private key</p>

<p><code>python
&gt;&gt;&gt; key.can_encrypt()
True
&gt;&gt;&gt; key.can_sign()
True
&gt;&gt;&gt; key.has_private()
True
</code></p>

<h3 id="section-4"><strong>加密</strong></h3>

<p>现在我们有了一对key，我们就可以加密一些数据了。加密的时候使用的是公钥: <code>public key</code> ：</p>

<p><code>python
&gt;&gt;&gt; public_key = key.publickey()
&gt;&gt;&gt; enc_data = public_key.encrypt('abcdefgh', 32)
&gt;&gt;&gt; enc_data
('\x11\x86\x8b\xfa\x82\xdf\xe3sN ~@\xdbP\x85
\x93\xe6\xb9\xe9\x95I\xa7\xadQ\x08\xe5\xc8$9\x81K\xa0\xb5\xee\x1e\xb5r
\x9bH)\xd8\xeb\x03\xf3\x86\xb5\x03\xfd\x97\xe6%\x9e\xf7\x11=\xa1Y&lt;\xdc
\x94\xf0\x7f7@\x9c\x02suc\xcc\xc2j\x0c\xce\x92\x8d\xdc\x00uL\xd6.
\x84~/\xed\xd7\xc5\xbe\xd2\x98\xec\xe4\xda\xd1L\rM`\x88\x13V\xe1M\n X
\xce\x13 \xaf\x10|\x80\x0e\x14\xbc\x14\x1ec\xf6Rs\xbb\x93\x06\xbe',)
</code></p>

<h3 id="section-5"><strong>解密</strong></h3>

<p>只要有用于解密的私钥(private key)解密是很简单的：</p>

<p><code>python
&gt;&gt;&gt; key.decrypt(enc_data)
'abcdefgh'
</code></p>

<h3 id="section-6"><strong>签名</strong></h3>

<p>对信息进行签名，可以用来验证信息的作者，让我们相信它的来源。下面这个例子展示了如何先算出信息的hash值，然后送给RSA key的<code>sign()</code>方法。使用其他算法如<code>DSA</code>或者是<code>ElGamal</code>也类似。</p>

<p><code>python
&gt;&gt;&gt; from Crypto.Hash import MD5
&gt;&gt;&gt; from Crypto.PublicKey import RSA
&gt;&gt;&gt; from Crypto import Random
&gt;&gt;&gt; key = RSA.generate(1024, random_generator)
&gt;&gt;&gt; text = 'abcdefgh'
&gt;&gt;&gt; hash = MD5.new(text).digest()
&gt;&gt;&gt; hash
'\xe8\xdc@\x81\xb144\xb4Q\x89\xa7 \xb7{h\x18'
&gt;&gt;&gt; signature = key.sign(hash, '')
&gt;&gt;&gt; signature
(1549358700992033008647390368952919655009213441715588267926189797
14352832388210003027089995136141364041133696073722879839526120115
25996986614087200336035744524518268136542404418603981729787438986
50177007820700181992412437228386361134849096112920177007759309019
6400328917297225219942913552938646767912958849053L,)
</code></p>

<h3 id="section-7"><strong>验证</strong></h3>

<p>只要有公钥，验证信息就很简单了。未加密的文本和签名一起被发送给接收方。接收方计算hash值然后调用公钥的<code>verify()</code>方法来进行验证：</p>

<p><code>python
&gt;&gt;&gt; text = 'abcdefgh'
&gt;&gt;&gt; hash = MD5.new(text).digest()
&gt;&gt;&gt; public_key.verify(hash, signature)
True
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Start With Python]]></title>
    <link href="http://lenciel.cn/2012/05/get-start-with-python/"/>
    <updated>2012-05-28T22:15:00+08:00</updated>
    <id>http://lenciel.cn/2012/05/get-start-with-python</id>
    <content type="html"><![CDATA[<p>刚刚开始使用Python开发的新手，遇到的第一个瓶颈（常常）就是缺乏对整个Python生态系统的理解。大家总是在网上搜索完成这件事或者那件事的“标准做法”，就像我们使用其他编程语言的时候常常需要掌握的一样。</p>

<p>在和几个朋友开始iDVR的开发的时候，我们在内部Wiki上维护过一个Python中常见问题列表。我们的目标是随着项目的不断进步，这个内部的wiki能够变成一个豪华的Q&amp;A索引，但是事实证明项目一忙起来就没有人去写Wiki了。</p>

<p>最近陆续有朋友问一些Python相关的问题，想想其实要用三言两语说清楚并不容易，就决定在那份wiki的基础上自己写一个版本，给那些刚开始使用Python（从来没有编过程的读起来可能没啥帮助）的同学。</p>

<h4 id="warning"><strong>Warning</strong></h4>

<p>Python编程是个大话题，不是这里讨论的内容。如果你没有太多编程经验，应该先去看一点儿Python的<a href="http://learnpythonthehardway.org/" target="_blank">入门书籍</a>。</p>

<p>另外，这片文章是基于Windows（最好是Win7 32bit）操作系统。潮人请不要问为啥不是Mac或者Linux，因为本座主要用的机器（包括码这篇Blog）都是用Win7 32bit。不过除开环境搭建，这里提到的大部分概念对其他系统都是适用的。</p>

<p>如果你有环境搭建上的问题，最靠谱的提问的地方不是CSDN或者百度知道，是<a href="http://stackoverflow.com/" target="_blank">Stack Overflow</a>。</p>

<h2 id="section">版本选择</h2>

<p>本座在某软件公司面试的时候别人看到简历上有Python就问，Python3用过吗？本座老实回答没有，结果面试官就停下他正在笔记本上google的微操，在脸上流露出一丝嘲讽…</p>

<p>不过，除了Python这门语言本身的开发者，大多数像本座这种使用Python的人，都没有紧跟Python3的步伐。Python3（或者叫Py3K）是一个大多数我熟悉的包，框架和工具都还没有完备支持的版本（在未来的数年本座也看不到希望）。如果不是想研究Python3的新特性或者具体实现，个人觉得初学的开发者使用2.7.x是最安全的版本（本座还在用进M公司就装好的2.6版本）。</p>

<p>如果你比较熟悉Python但是不确定该不该升级到Python3，不妨先去观赏一下<a href="http://python3wos.appspot.com/">Python 3 Wall of Shame</a> (墙外，你们懂的)。</p>

<h2 id="vm">VM选择</h2>

<p>Python是<a href="http://zh.wikipedia.org/zh-hk/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80" target="_blank">脚本语言</a>，因此需要VM。CPython是最主流的选择，也被当成其他VM实现时的参考。其他常见的还有用Python实现的<a href="http://pypy.org/">PyPy</a>，用Java实现的<a href="http://www.jython.org/">Jython</a> 以及用Microsoft .Net CLR实现的<a href="http://ironpython.net/">IronPython</a>。如果你不是非常非常确定你自己要选用别的，就安装CPython吧。</p>

<p>换句话说，前面这堆关于VM和版本选择的建议在你看来不知所云，你需要的就是<a href="http://www.python.org/getit/" target="_blank">CPython 2.7.x版本</a>。</p>

<h2 id="python">Python安装</h2>

<p>下载之后的.exe安装文件安装的时候有一个地方需要注意：如果你是在Vista/Win7这样的C盘权限控制异常严格的操作系统，最好用右键“Run as administrator”。这点也适用于你下载到的被其他人编译成exe发布的Python package。嗯，什么是package？</p>

<h2 id="package">理解Package</h2>

<p>Python没有一个内置的package管理体系。实际上Python下面一个package是什么也是一个很“不具体”的概念。就像前面提到的，Python下面的代码是以module为单位存在的。每个module既可以是一个只有一个函数的文件，也可以是一个包含了一个或者多个子module的目录。而module和package之间的区别是非常模糊的，每个module都可以被认为是一个package。</p>

<p>和所有的编程环境一样，在Python下面有一些函数和类是全局可见的（<code>str</code>，<code>len</code>，<code>Exception</code>等等），而另外一些需要通过<code>import</code>语句导入，比如：</p>

<p><code>python
&gt;&gt;&gt;import os
&gt;&gt;&gt;from os.path import basename, dirname
</code></p>

<p>这里<code>import</code>被调用的时候，Python是从哪里把这些module导入的呢？其实，在你安装Python的时候，module的导入路径已经被自动设置过了。这个过程的具体实现是跟你运行的平台相关的，你可以通过<code>sys.path</code>来查看被设置的路径究竟是什么。比如本座的是：</p>

<p><code>bash
['',
'C:\\Python26\\lib\\site-packages\\demjson-1.4-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\anyjson-0.2.5-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\pmw-1.3.2-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\paramiko-1.7.6-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\treewidgets-1.0a1-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\mechanize-0.2.3-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\pylint-0.22.0-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\logilab_astng-0.21.0-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\logilab_common-0.53.0-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\unittest2-0.5.1-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\virtualenv-1.5.1-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django_staticfiles-0.3.2-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django_attachments-0.3dev-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django_ajax_validation-0.1.4-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django_email_confirmation-0.2.dev4-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\distribute-0.6.10-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django_timezones-0.2.dev1-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django-1.3-py2.6.egg',
'C:\ \Python26\\lib\\site-packages\\rbtools-0.3.2-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\django_debug_toolbar-0.8.4-py2.6.egg',
'C:\\Python26\\lib\\site-packages\\suds-0.4-py2.6.egg',
'C:\\Windows\\system32\\python26.zip',
'C:\\Python26\\DLLs',
'C:\\Python26\\lib',
'C:\\Python26\\lib\\plat-win',
'C:\\Python26\\lib\\lib-tk',
'C:\\Python26',
'C:\\Python26\\lib\\site-packages',
'C:\\Python26\\lib\\site-packages\\PIL',
'C:\\Python26\\lib\\site-packages\\wx-2.8-msw-unicode']
</code></p>

<p>Python在导入的module的时候，是按照这个列表“自顶向下，见好就收”的方式运作的。也就是说如果你正好机器上有两个路径下面安装了同样名称的module，先被搜索到的那个就会被导入。有的时候，你确信自己受到了这种机制的干扰，也可以通过下面的办法来hack回来：</p>

<p><code>python
sys.path.insert(, 'path\\to\\your\\packages')
</code></p>

<p>进行一段时间的Python开发过后你总是会有很多的包，于是这个办法你会觉得非常的方便。但是，请结合后面的内容默默记住，不到万不得已，不要这样hack。</p>

<h5 id="the-pythonpath"><strong>The PYTHONPATH</strong></h5>

<p><code>PYTHONPATH</code>是一个环境变量（可以win+break到高级设置里面去设置），可以简单的理解它就是Windows下面的<code>PATH</code>变量，不过只是对Python可见而已。在很多Python的教程里面，会说所有你想要让Python搜索module的路径，都应该加到这个变量对应的列表里面。</p>

<p>其实前面提到过，在Python安装的时候搜索路径已经被自动设置过一次。所以<code>PYTHONPATH</code>这个变量并不是必须加的。而且，作为开发环境满坑满谷的程序员，我们都喜欢把Path里面搞得干干净净的（比如本座干活都习惯在bat里面先设置相关的路径再起相应的Eclipse）。这种一启动就load一堆的办法，自己喜欢也可以用，但是更推荐后面会说的<code>virtualenv</code>。</p>

<h5 id="package-1"><strong>第三方package</strong></h5>

<p>首先，入门之后要开始正经干活，你总是需要安装一些第三方的Package。安装的办法有：</p>

<ol>
  <li>下载别人编译好的Windows的版本exe</li>
  <li>使用<code>pip</code>或者<code>easy_install</code></li>
  <li>自己从代码安装</li>
</ol>

<p>三种办法干的事情都是类似的：下载package的依赖包，编译（需要的话）和拷贝目标文件到一个默认的第三方Package路径。那么，哪里去找安装需要的文件呢？一般来说：</p>

<ol>
  <li>Google</li>
  <li><a href="http://pypi.python.org/pypi">Python Package Index(or PyPI)</a></li>
  <li>各种开源的代码库(<a href="https://launchpad.net/">Launchpad</a>/<a href="http://github.com/">GitHub</a>/<a href="https://bitbucket.org/">BitBucket</a>）</li>
</ol>

<h5 id="exe"><strong>安装别人编译好的exe</strong></h5>

<p>注意下载的时候看清别人编译是在32还是64bit的Windows，Python的版本和你用的一致不一致。运行exe的时候注意右键Run as Administrator。就这么简单。</p>

<h5 id="pip"><strong>使用pip</strong></h5>

<p><code>easy_install</code>已经慢慢失宠了，主要介绍一下它的替代品：<code>pip</code>。</p>

<p><code>pip</code>是用来安装和管理Python Package的工具。它不是随Python默认安装的，因此需要额外安装。安装完毕之后我们就可以在命令行里面调用它来管理package了。比如你要安装<code>pygame</code>这个package，只需要：</p>

<div class="wp_syntax">
  <div class="code">
    <pre class="python" style="font-family:monospace;">pip install pygame</pre>
  </div>
</div>

<p>而如果你想删除它的话，则运行：</p>

<p><code>bash
pip uninstall pygame
</code></p>

<p><code>pip</code>默认会按照你指定的名字，搜索和安装最新的stable版本的包。但我们常常需要安装某个特定版本的包，这个时候需要你在命令行里面指定：</p>

<p><code>bash
pip install pygame==version_number
</code></p>

<p>如果你安装的版本不对，可以通过<code>upgrade</code>命令升级/降级到指定版本：</p>

<p><code>bash
pip install pygame==version_number –upgrade
</code></p>

<p>由于Python高度依赖开源团体，很多最新的package都没有在PyPI上面，我们常常需要从代码库直接安装package。在<code>pip</code>下面可以直接</p>

<p><code>bash 
$ pip install git+http://somedomain.com/path/to/git-repo#egg=packagename
$ pip install hg+http://somedomain.com/path/to/hg-repo#egg=packagename
$ pip install svn+http://somedomain.com/path/to/svn-repo#egg=packagename
</code></p>

<p>当然，前提是git/hg/svn这些工具你都安装好了并且在命令行里面能够执行。</p>

<p>上面这些<code>egg</code>是什么蛋呢？你可以认为它们就是Package源代码和一些metadata打成的压缩包。<code>pip</code>会读取<code>egg</code>里面的<code>setup.py</code>文件，然后安装<code>egg</code>到你的文件系统。</p>

<h5 id="python-1"><strong>从Python源码安装</strong></h5>

<p>从源代码安装虽然是最复杂的，但是也没那么复杂。把你下载的源代码解压之后，找到<code>setup.py</code>所在的路径，然后运行下面的命令：</p>

<p><code>bash
python setup.py install
</code></p>

<p>也许你觉得这样也挺容易的，为啥要去用<code>pip</code>？因为：</p>

<ul>
  <li>省去你上网找源代码，解压，安装这些动作</li>
  <li>更重要的是，<code>pip</code>不但装，而且管。你可以升级和降级一个Package。</li>
</ul>

<h5 id="package-2"><strong>安装需要编译的package</strong></h5>

<p>这种一般是因为Package里面有c/cpp的代码。如果你能找到别人编译好的exe文件或者用<code>pip</code>，最好不要自己折腾。只有非常非常罕见的情况下你需要自己编译，过程中一般来说都会需要用<code>cygwin</code>之类的东西，在前面几次你可以多看看每个Package的<code>readme</code>关于编译的说明。</p>

<h2 id="section-1">开发环境</h2>

<h5 id="virtualenv"><strong>virtualenv</strong></h5>

<p><code>virtualenv</code>无疑是当前Python开发者心中“必知必会”类的工具了。<code>virtualenv</code>主要就是提供一个“独立的”Python开发环境。为什么需要“独立”的开发环境？在不知道<code>virtualenv</code>之前Python包满坑满谷的本座自然是有很多槽可以吐，不过最好的答案是<code>virtualenv</code>的文档里面说的：</p>

<p><blockquote><p>The basic problem being addressed is one of dependencies and versions, and indirectly permissions. Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python2.7/site-packages (or whatever your platform’s standard location is), it’s easy to end up in a situation where you unintentionally upgrade an application that shouldn’t be upgraded.</p></blockquote></p>

<p>简单来说，就是每个工程使用自己独立的<code>virtualenv</code>进行开发，所有该工程需要依赖的Package都安装在这个<code>virutalenv</code>里面。<code>virutalenv</code>的安装同样是使用<code>pip</code>：</p>

<p><code>bash
$ pip install virtualenv
</code></p>

<p>然后就可以建立属于自己项目的开发环境：</p>

<p>``` bash
D:\Lenciel\Temp mkdir my_project_env</p>

<p>D:\Lenciel\Temp\virtualenv –distribute my_project_env</p>

<p>New python executable in my_project_env\Scripts\python.exe
  Installing distribute……………..done.
```</p>

<p>建立的目录下面会自动的安装好<code>pip</code>等工具：</p>

<p><code>bash
-my_project_env
  |-- Scripts # -- Python解释器的拷贝/pip脚本/activiate脚本/deactivate脚本等
  |-- Lib     # -- 所有库（包括激活后使用pip安装的库都会放在这里
</code></p>

<p>在命令行执行activate脚本就可以激活你新建的环境。环境被激活后，主要通过下面两个功能保持独立完整性：</p>

<ol>
  <li>当你在被激活的环境里面使用<code>pip</code>安装一个Package的时候，它只会被安装在这个工作目录下面</li>
  <li>当你<code>import</code>的时候，会先从工作目录下面去搜索，然后才会搜索系统目录下的</li>
</ol>

<p>需要注意的是，在系统目录下面安装的包，对所有的<code>virtualenv</code>建立的环境都是可见的。如果你不想在你建立的<code>virtualenv</code>里面看到这些包，可以使用<code>--no-site-packages</code>参数建立开发环境：</p>

<p><code>bash
$ virtualenv my_project_venv --no-site-packages
</code></p>

<h2 id="section-2">其他的工具</h2>

<h5 id="section-3"><strong>编辑器</strong></h5>

<p>在不同的项目里面本座用过Vim/Sublime text 2/Eclipse+PyDev/PyCharm。现在Vim和PyCharm用得比较多一点，PyDev一直有一些诡异的问题。比如那个“<a href="https://www.google.com.hk/search?num=30&amp;hl=en&amp;newwindow=1&amp;c2coff=1&amp;safe=strict&amp;site=&amp;source=hp&amp;q=Unresolved+import+pydev&amp;btnK=Google+Search&amp;qscrl=1" target="_blank">Unresolved import</a>”从一开始到现在都好像没有被真正解决过。</p>

<h5 id="section-4"><strong>编码规范</strong></h5>

<p><a href="http://www.python.org/dev/peps/pep-0008/">PEP 0008</a>推荐了非常完整的一套编码规范，目的就是让全世界编写Python脚本的同学们用相同的方式去对齐代码，命名变量、类和函数。每个严肃的Pythoner都应该认真的学习和理解这些规范，并且贯彻执行。</p>

<h5 id="python-2"><strong>Python标准库</strong></h5>

<p>Python的标准库提供了相当完备的功能。就像Java的工程师需要熟悉系统自带的API文档一样，了解标准库的用法是非常有好处的。另外，这些标准库都是很好的范例，特别是在支持跨平台使用这方面。</p>

<p>官方文档在<a href="http://docs.python.org/library/" target="_blank">这里</a>。</p>

<h2 id="section-5">嗯哼</h2>

<p>前面列了不少东西，只是希望给新手一个上路指引。Python下面有用的工具，有趣的包很多很多。随着你学习和应用这门语言，不断深入它，你会自己慢慢发觉那些你自己最需要/愿意熟悉的部分。</p>

<p>Python的另外一大财富就是它的开源社区，条件成熟的时候，你也应该参与到这样的开发活动里面去。</p>

<p>最后是每个Pythoner都津津乐道的Zen Of Python送给刚开始学习的朋友。</p>

<p>``` python
»&gt;import this
The Zen of Python, by Tim Peters</p>

<p>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren’t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one– and preferably only one –obvious way to do it.
Although that way may not be obvious at first unless you’re Dutch.
Now is better than never.
Although never is often better than <em>right</em> now.
If the implementation is hard to explain, it’s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea – let’s do more of those!
```</p>

<p>Happy Pythoning…!!</p>

]]></content>
  </entry>
  
</feed>
